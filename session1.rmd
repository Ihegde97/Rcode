---
title: "session1"
author: "Ishwara Hegde"
date: "10/1/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Session 1 

Below was the prompt that Dmitry gave us in class:

```{prompt}

library(splines)

set.seed(1234)
rm(list = ls())

#Loading data

data_africa <- read.table("http://www-stat.stanford.edu/~tibs/ElemStatLearn/datasets/SAheart.data",
	sep=",",head=T,row.names=1)

Y <- data_africa[,'chd']
X_1 <- data_africa[,'sbp'] 
X_2 <- data_africa[,'alcohol']
X_3 <- data_africa[,'tobacco']


## Problem 1: Create a natural cubic spline with 2 degrees of freedom (3 knots) using ns function for X_1, X_2, and X_3

## Problem 2: run a logit regression (use glm function) with Y as a response and splines of X_1, X_2, and X_3 as regressors; compute the mean squared error;
## The glm.predict function (with type = 'response') will be handy


## Problem 3: do a bootstrap simulation (function `sample' will be useful) with B = 1000 replications, in each simulation compute
## run the logit exercise as in Problem 2, and compute the estimation error. Plot its distribution (use plot(density(x))) over B bootstrap samples.


```

```{r, Preamble:Loading Data and Packages}
library(splines)
library(broom)
library(ggplot2)
library(dplyr)          # for data manipulation
library(tidyr)          # for data tidying
library(extrafont)
loadfonts(device = "win", quiet = TRUE)

set.seed(1234)
rm(list = ls())

#I just use Dmitry's code for this part 

data_africa <- read.table("http://www-stat.stanford.edu/~tibs/ElemStatLearn/datasets/SAheart.data",
	sep=",",head=T,row.names=1)

Y <- data_africa[,'chd']
X_1 <- data_africa[,'sbp'] 
X_2 <- data_africa[,'alcohol']
X_3 <- data_africa[,'tobacco']



```

## Part 1: natural Cubic Splines 
A natural cubic spline fits locally a cubic polynomial in each of the $\psi$ 
knots except in the first and the last knot where a linear function is split.

```{r part 1}
spline_X1 <- ns(X_1, df=2,intercept=FALSE)
spline_X2 <-ns(X_2,df=2,intercept = FALSE)
spline_X3 <- ns(X_3, df=2,intercept=FALSE)

#Adding 

#Creating a tibble 
X1_df <- tibble("sbp"=X_1,"X11"=spline_X1[,1],"X12"=spline_X1[,2])
X2_df <- tibble("alcohol"=X_2,"X21"=spline_X2[,1],"X22"=spline_X2[,2])
X3_df <-tibble("tobaco"=X_3,"X31"=spline_X3[,1],"X32"=spline_X3[,2])
#Creating a master tibble 
data_X<-tibble(X1_df,X2_df,X3_df)

#Graphing 
#First spline for X_3
ggplot(data=X3_df,mapping=aes(tobaco,X31))+
        geom_point()+labs(title = "First Spline")+xlab("Tobacco")+ylab("Spline")+
        theme_minimal() +
        theme(axis.title = element_blank(),
              panel.grid.minor = element_blank(),
              legend.position = "none",
              text = element_text(family = "Georgia"),
              axis.text.y = element_text(size = 12),axis.text.x = element_text(size = 12),
              plot.title = element_text(size = 20, margin = margin(b = 10), hjust = 0))


#Second SPline 

ggplot(data=X3_df,mapping=aes(tobaco,X32))+
        geom_point()+labs(title = "Second Spline")+xlab("Tobacco")+ylab("Spline")+
        theme_minimal() +
        theme(axis.title = element_blank(),
              panel.grid.minor = element_blank(),
              legend.position = "none",
              text = element_text(family = "Georgia"),
              axis.text.y = element_text(size = 12),axis.text.x = element_text(size = 12),
              plot.title = element_text(size = 20, margin = margin(b = 10), hjust = 0))


```

For part (ii) we need to use the predict.glm function to run a logit of Y on
the spline of X_1, X_2 and X_3.

```{r, Logit}
base_model<- glm(Y~spline_X1+spline_X2+spline_X3,family="binomial")

#Combining the splines into one df 
combined_X<-data.frame(cbind(spline_X1,spline_X2,spline_X3))

base_model_prediction <- predict.glm(base_model,combined_X,type=c("response"))

#MSE
MSE_base <- mean((Y-base_model_prediction)^2)

```

For part (iii) run a 1000 bootstrap replications and in each simulation compute
logit,predict and then find MSE.Plot the MSE as a density plot.

```{r, bootstrap}

#Using the sample command  (bootstrap functions NOT ALLOWED)
B<-1000
MSE_mat <-matrix(,nrow=B,ncol=1)
for (i in 1:B) {
        bs_sample<-sample(1:nrow(data_X),nrow(data_X),replace=TRUE)
        Y_bs <-Y[bs_sample,]
        bs_model<-glm(Y_bs~spline_X1[bs_sample,]+spline_X2[bs_sample,]+
                              spline_X3[bs_sample,],family="binomial")
        bs_comb_X <-data.frame(cbind(spline_X1[bs_sample,],spline_X2[bs_sample,]
                                     ,spline_X3[bs_sample]))
        
        bs_model_prediction <- predict.glm(bs_model,bs_comb_X,type=c("response"))

        #MSE
        MSE_mat[i,1] <- mean((Y-bs_model_prediction)^2)
        
   
}

#Simple plot 
plot(density(MSE_mat[,1]),main = 'Distribution of the Estimation Error')



```